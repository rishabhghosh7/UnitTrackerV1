// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const addUnit = `-- name: AddUnit :exec
INSERT INTO Unit(project_id, created_ts, updated_ts) VALUES(?, ?, ?)
`

type AddUnitParams struct {
	ProjectID int64
	CreatedTs int64
	UpdatedTs int64
}

func (q *Queries) AddUnit(ctx context.Context, arg AddUnitParams) error {
	_, err := q.db.ExecContext(ctx, addUnit, arg.ProjectID, arg.CreatedTs, arg.UpdatedTs)
	return err
}

const createProject = `-- name: CreateProject :exec
INSERT INTO Project(name, desc, created_ts, updated_ts) VALUES(?, ?, ?, ?)
`

type CreateProjectParams struct {
	Name      string
	Desc      sql.NullString
	CreatedTs int64
	UpdatedTs int64
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.ExecContext(ctx, createProject,
		arg.Name,
		arg.Desc,
		arg.CreatedTs,
		arg.UpdatedTs,
	)
	return err
}

const getProject = `-- name: GetProject :many
SELECT id, name, desc, created_ts, updated_ts FROM Project WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetProject(ctx context.Context, ids []int64) ([]Project, error) {
	query := getProject
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Desc,
			&i.CreatedTs,
			&i.UpdatedTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT id, name, desc, created_ts, updated_ts FROM Project WHERE name=?
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByName, name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Desc,
		&i.CreatedTs,
		&i.UpdatedTs,
	)
	return i, err
}

const getUnits = `-- name: GetUnits :many
SELECT id, project_id, created_ts, updated_ts FROM Unit WHERE project_id IN (/*SLICE:project_ids*/?)
`

func (q *Queries) GetUnits(ctx context.Context, projectIds []int64) ([]Unit, error) {
	query := getUnits
	var queryParams []interface{}
	if len(projectIds) > 0 {
		for _, v := range projectIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:project_ids*/?", strings.Repeat(",?", len(projectIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:project_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CreatedTs,
			&i.UpdatedTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, desc, created_ts, updated_ts FROM Project
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Desc,
			&i.CreatedTs,
			&i.UpdatedTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :exec
UPDATE Project SET desc = ? WHERE id = ?
`

type UpdateProjectParams struct {
	Desc sql.NullString
	ID   int64
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject, arg.Desc, arg.ID)
	return err
}
