// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
)

const addUnit = `-- name: AddUnit :exec
INSERT INTO Unit(project_id, created_ts, updated_ts) VALUES(?, ?, ?)
`

type AddUnitParams struct {
	ProjectID int64
	CreatedTs int64
	UpdatedTs int64
}

func (q *Queries) AddUnit(ctx context.Context, arg AddUnitParams) error {
	_, err := q.db.ExecContext(ctx, addUnit, arg.ProjectID, arg.CreatedTs, arg.UpdatedTs)
	return err
}

const createProject = `-- name: CreateProject :exec
INSERT INTO Project(name, desc, created_ts, updated_ts) VALUES(?, ?, ?, ?)
`

type CreateProjectParams struct {
	Name      string
	Desc      sql.NullString
	CreatedTs int64
	UpdatedTs int64
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.ExecContext(ctx, createProject,
		arg.Name,
		arg.Desc,
		arg.CreatedTs,
		arg.UpdatedTs,
	)
	return err
}

const getProject = `-- name: GetProject :many
SELECT id, name, desc, created_ts, updated_ts FROM Project WHERE id IN (?)
`

func (q *Queries) GetProject(ctx context.Context, id int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Desc,
			&i.CreatedTs,
			&i.UpdatedTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnits = `-- name: GetUnits :many
SELECT project_id, created_ts, updated_ts FROM Unit WHERE project_id IN (?)
`

type GetUnitsRow struct {
	ProjectID int64
	CreatedTs int64
	UpdatedTs int64
}

func (q *Queries) GetUnits(ctx context.Context, projectID int64) ([]GetUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnits, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitsRow
	for rows.Next() {
		var i GetUnitsRow
		if err := rows.Scan(&i.ProjectID, &i.CreatedTs, &i.UpdatedTs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, desc, created_ts, updated_ts FROM Project
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Desc,
			&i.CreatedTs,
			&i.UpdatedTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
